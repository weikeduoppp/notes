# 2022面试题

## html

#### 从浏览器地址栏输入 url 到请求返回发生了什么?

浏览器 URL 解析 -> DNS解析(获取ip地址, 先缓存, 没有根域名服务器查 -> com顶级域名 -> 权威域名)  -> TCP链接(http三次握手, https多了一个TLS加密协议的握手过程) -> http请求 -> 服务器响应 -> 浏览器开始渲染 -> 四次挥手关闭链接

问: TCP 连接为啥三次握手? 

客户端和服务端要进行可靠传输，那么就需要**确认双方的接收和发送能力**。第一次握手可以确认客服端的**发送能力**，第二次握手，确认了服务端的**发送能力和接收能力**，所以第三次握手才可以确认客户端的**接收能力**。不然容易出现丢包的现象



## CSS

## JS

#### 如何判断变量是否为数组？

```js
Array.isArray(arr);
arr instanceof Array;
Object.prototype.toString.call(arr) === '[object Array]';
```

#### 根据 0.1+0.2 ! == 0.3，讲讲 IEEE 754 ，如何让其相等？

原因: 

- **进制转换:** js数字计算时, 会转换为二进制. 最大存储 **53位** 有效数字, 大于会被截掉. 导致精度丢失
- **对阶运算:** 由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（`0舍1入`），尾数位移时可能会发生数丢失的情况，影响精度

如何让其相等, 

- 字符串相加

```js
// 字符串数字相加
var addStrings = function (num1, num2) {
  let i = num1.length - 1;
  let j = num2.length - 1;
  const res = [];
  let carry = 0;
  while (i >= 0 || j >= 0) {
    const n1 = i >= 0 ? Number(num1[i]) : 0;
    const n2 = j >= 0 ? Number(num2[j]) : 0;
    const sum = n1 + n2 + carry;
    res.unshift(sum % 10);
    carry = Math.floor(sum / 10);
    i--;
    j--;
  }
  if (carry) {
    res.unshift(carry);
  }
  return res.join("");
};

function isEqual(a, b, sum) {
  const [intStr1, deciStr1] = a.toString().split(".");
  const [intStr2, deciStr2] = b.toString().split(".");
  const inteSum = addStrings(intStr1, intStr2); // 获取整数相加部分
  const deciSum = addStrings(deciStr1, deciStr2); // 获取小数相加部分
  return inteSum + "." + deciSum === String(sum);
}

console.log(isEqual(0.1, 0.2, 0.3)); // true
```

#### new 实现

 new 实现了哪些功能?

- 能访问构造函数的属性
- 把这个对象的构造原型(`__proto__`)指向函数的原型对象`prototype`，并绑定this
- 能访问函数原型中的属性.
- 如果构造函数带返回值. 返回类型如果是对象. 则返回这个对象. 否则还是实例对象. 

```js
function New(fn) [
  var obj = {}
  obj.__proto__ = fn.prototype;
  var res = fn.apply(obj, [...arguments.slice(1)])
  return typeof res === 'object' ? res : obj; 
]
```

Promise.all 的实现

```js
// Promise.all([A, B])
Promise.all = function(arr) {
    let result = []
    return new Promise((resolve, reject)=>{
        let remaining = arr.length
        function res(val, i) {
            try {
                if (val && (typeof val === 'function' || typeof val === 'object')) {
                    const {
                        then
                    } = val;
                    // 遗漏
                    if (typeof then === 'function') {
                        
                        then.call(
                            val,
                        	function(value) {
                                res(value, i)
                            },
                        	reject
                        );
                        return; 
                    }
                }
                result[i] = val;
                if (--remaining === 0) {
                    resolve(result)
                }
            } catch(error) {
                reject(error)
            }

        }
        for (let i = 0; i < arr.length; i++) {
            res(arr[i], i)
        }
    })
}
```

## [http](https://juejin.cn/post/6844904100035821575)

#### GET 和 POST 的区别。

- 从**缓存**的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。

- 从**编码**的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。

- 从**参数**的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。

- 从**幂等性**的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)

- 从 **TCP** 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)

#### 简要概括一下 HTTP 的特点？HTTP 有哪些缺点？

特点: 

1. **灵活可扩展**，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。
2. **无状态**。这里的状态是指**通信过程的上下文信息**，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。
3. **无连接**  无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间
4. **简单快速** 客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快

缺点: 

1. **无状态** 对于长链接的场景来说, 需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。
2. **明文传输** 协议里的报文 是文本形式 这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。`WIFI陷阱`就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息
3. **队头阻塞问题 ** 当开始长链接. 同一时刻只能处理一个请求. 请求时间过长的情况下. 其他请求只能处于阻塞状态

#### HTTP1.1 如何解决 HTTP 的队头阻塞问题？

- **并发连接**

  - 对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。

- **域名分片**

  - 一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。

    比如 content1.sanyuan.com 、content2.sanyuan.com。

    这样一个`sanyuan.com`域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。

## React

### 为什么要自定义事件机制？

- 抹平浏览器差异，实现更好的跨平台。
- 避免垃圾回收，React 引入事件池，在事件池中获取或释放事件对象，避免频繁地去创建和销毁。
- 方便事件统一管理和事务机制。

### Class component

#### 生命周期

<img src="https://images.yewq.top/uPic/image-20220214230110035.png" alt="image-20220214230110035" style="zoom:150%;" />

挂载阶段: constructor() -> getDerivedStateFromProps() 返回一个对象更新state, 是否更新state -> render() -> 更新Dom树 -> componentDidMount() 

更新阶段:  getDerivedStateFromProps() -> shouldComponentUpdate() 是否更新这次. -> render() -> getSnapShotBeforeUpdate() 拿到更新前的Dom相关值 -> 更新Dom树 -> componentDidUpdate()

卸载阶段: componentWillUnmount()

### hook

#### 为什么不能在条件语句中写 hook

hook 在每次渲染时的查找是根据一个“全局”的下标对链表进行查找的，如果放在条件语句中使用，有一定几率会造成拿到的状态出现错乱.

#### HOC 和 hook 的区别

hook 复用**逻辑**. HOC复用**逻辑和视图**

#### useEffect 和 useLayoutEffect 区别

函数组件一次state更新的过程: 

1. 某state发生了变化
2. React内部更新state
3. 处理更新组件的Dom节点
4. Dom更新渲染
5. Dom更新后 (Layout阶段后)

`useEffect` 在第 4 步之后执行，且是异步的，保证了不会阻塞浏览器进程。 `useLayoutEffect` 在第 3 步至第 4 步之间执行，且是同步代码，所以会阻塞后面代码的执行

#### useEffect 依赖为空数组与 componentDidMount 区别

在 `render` 执行之后，`componentDidMount` 会执行，如果在这个生命周期中再一次 `setState` ，会导致再次 `render` ，返回了新的值，浏览器只会渲染第二次 `render` 返回的值，这样可以避免闪屏。

但是 `useEffect` 是在真实的 DOM 渲染之后才会去执行，这会造成两次 `render` ，有可能会闪屏。(useEffect时commit完成后异步调用)

实际上 `useLayoutEffect` 会更接近 `componentDidMount` 的表现，它们都同步执行且会阻碍真实的 DOM 渲染的。 useLayoutEffect和componentDidMount调用时机一致，也是在layout阶段同步调用.

#### React.memo() 和 React.useMemo() 的区别

- memo是高阶组件. 浅比较props, 引用类型可以用第二个参数手动比价
- useMemo 返回一个缓存值. 只有依赖项发生变化才会重新执行.
- useCallback 根据依赖项缓存函数

  - 有很多时候，我们在 `useEffect` 中使用某个定义的外部函数，是要添加到 `deps` 数组中的，如果不用 `useCallback` 缓存，这个函数在每次重新渲染时都是一个完全新的函数，也就是引用地址发生了变化，这就会导致 `useEffect` 总会无意义的执行。


## Webpack

### webpack5 和 webpack4 的区别有哪些 ？





## 经历

### react使用优势?

1. 虚拟Dom
2. 组件化 将页面拆分成若干个组件，并且react一个组件同时耦合了css，js ,image，这种模式整个垫付了过去的传统模式
3. JSX语法
4. 单向数据流

是个库. 项目使用需要引入react-router, 数据管理react-redux配合

### react 怎么diff?

react的diff 策略

- **同级diff, 忽略跨层级的移动操作**
- **不同类型的组件生成不同的树**
- **同层级子节点可以使用key作为区分**

其中Diff分为两类：

1. 当`newChild`类型为`object`、`number`、`string`，代表同级只有一个节点
2. 当`newChild`类型为`Array`，同级有多个节点

同级的节点的diff分为:
**单节点diff**: 
先看上次的更新child是否存在. 

	- 不存在 新建fiber节点
	- 存在看是否能够复用
		- 先看key是否相同
			- key不相同 将该fiber标记为删除, 后面可能还有兄弟fiber.
			- key相同 接下来看type是否相同
				- type相同则复用
				- type不相同 将该fiber及其兄弟fiber全部标记为删除


**多节点diff**: 
>虽然本次更新的JSX对象 newChildren为数组形式，但是和newChildren中每个组件进行比较的是current fiber，同级的Fiber节点是由sibling指针链接形成的单链表，即不支持双指针遍历。
>
>在日常开发中，相较于`新增`和`删除`，`更新`组件发生的频率更高。 所以`Diff`会优先判断当前节点是否属于`更新`。

Diff 分两轮遍历:

第一轮遍历:处理更新的节点
第二轮遍历: 处理剩下的不属于更新的节点

第一轮遍历:

1. `let newidx = 0`, 遍历`newChildren`; 将`newChildren[i]`与`oldFilber`进行比较. 如果可以复用, 继续遍历
2. `newidx++`; 继续将`newChildren[i]` 与 `oldFilber.sibling` 进行比较 . 如果可以复用, 继续遍历
3. 如果不可以复用, 分两种:
   1. `key `不同 **直接第一轮遍历结束**
   2. `key `相同` type`不同.  将oldFilber标记删除, 继续遍历
4. 如果` newChildren` 遍历完 ( `newIdx === newChildren.length - 1 `) 或者` oldFiber `遍历完 `oldFiber === bull `, 跳出遍历，**第一轮遍历结束。**

第一轮遍历的结果会有几种情况:

1. `newChildren` 与 `oldFiber` 都遍历完了 --- 说明这次只是更新节点,` Diff` 结束
2. `newChilderen`遍历完了, `oldFilber`没有遍历完 --- 说明这次删除节点, 只需将剩下`oldFilber`标记` deletion`
3. `newChilderen`没有遍历完, `oldFilber`遍历完了 --- 说明这次新增节点, 只需将剩下` newChilderen` 遍历生成`filber` 标记为新增
4. `newChilderen`和 `oldFilber`都没有遍历完, --- 说明这次更新中改变了位置

第二轮遍历: 

>  没遍历完的节点

由于有节点改变了位置，所以不能再用位置索引`i`对比前后的节点，那么如何才能将同一个节点在两次更新中对应上呢？

我们需要使用`key`。

为了快速的找到`key`对应的`oldFiber`，我们将所有还未处理的`oldFiber`存入以`key`为key，`oldFiber`为value的`Map`中。

```javascript
const existingChildren = mapRemainingChildren(returnFiber, oldFiber);
```

接下来遍历剩余的`newChildren`，通过`newChildren[i].key`就能在`existingChildren`中找到`key`相同的`oldFiber`。

- 找到相同key	
  - type是否相同 可复用 
    - 可复用 existingChildren.delete(newFiber.key)
  - 不可复用 新建fiber
- 没找到新建fiber

剩余existingChildren如果还有 遍历筛入deletions

改变了位置的情况

### react性能优化? 项目上的性能优化?

React(代码层面): 

- 组件: React.useMemo; PureComponent, shouldComponentUpdate
- 函数: useCallback. useMemo;
- 避免内联函数.
- React.lazy与 React.Suspense
- 减少渲染(重排和重绘)
- 防抖和节流（resize，scroll，input）。

构建上的性能优化: 

- **CDN加速**: **output.publicPath** 静态资源配置cdn
- **压缩css** plugin: `optimize-css-assets-webpack-plugin` `cssnano`
- **压缩html**: `HtmlWebpackPlugin.minify ` 
- **tree shaking 清除无用的css, js**: 
  - css: glob-all@3.2.1 `purify-css@1.2.5` `purifycss-webpack@0.7.0` 
  - js: `optimization.usedExports`: true 且只有mode: 'production'才生效. 消除副作用: package.json中的 sideEffects: ['*.less', '*.css', '@babel/polyfill'] // 免除消除
- **代码分割 optimization.splitChunks **: 分离公共文件. 
- **开启 gzip 压缩** webpack 中使用 `compression-webpack-plugin` ，node 作为服务器也要开启，使用 `compression`。

其它：

- 使用 http2。因为解析速度快，头部压缩，多路复用，服务器推送静态资源。
- 使用服务端渲染。
- 图片压缩。
- 使用 http 缓存，比如服务端的响应中添加 `Cache-Control / Expires` 。

### webpack 压缩js的插件?

多线程压缩js:  webpack-parallel-uglify-plugin, 

- `uglifyjs-webpack-plugin`：不支持 ES6 压缩 (Webpack4 以前)
- `terser-webpack-plugin`: 支持压缩 ES6 (Webpack4)

### hook与class组件的区别?

- hook写法更简洁. 比class更` 声明式`

- hook使得函数组件更容易复用. 比class更` 函数式`

- 复杂组件中 class起初简单. 后面逐渐被状态逻辑和副作用充斥. 每个生命周期包含不相关的逻辑. 难以拆分. 而hook,可以将组件相互关联的部分拆分成更小的函数, 例如请求数据, 设置订阅等. 而非按生命周期来划分.

- hook可以使你在无需改变组件结构的情况下复用状态逻辑. Class组件复用状态逻辑需要使用高级组件嵌套,或者provider. render props

  

### 使用typescript的好处?

- 增加了代码的可读性和可维护性
  - 类型系统实际上是最好的文档
  - 可以在编译阶段就发现大部分错误
  - 增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等
- 静态类型检查
