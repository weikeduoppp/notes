# 2022面试题

## html

#### 从浏览器地址栏输入 url 到请求返回发生了什么?

浏览器 URL 解析 -> DNS解析(获取ip地址, 先缓存, 没有根域名服务器查 -> com顶级域名 -> 权威域名)  -> TCP链接(http三次握手, https多了一个TLS加密协议的握手过程) -> http请求 -> 服务器响应 -> 浏览器开始渲染 -> 四次挥手关闭链接

问: TCP 连接为啥三次握手? 

客户端和服务端要进行可靠传输，那么就需要**确认双方的接收和发送能力**。第一次握手可以确认客服端的**发送能力**，第二次握手，确认了服务端的**发送能力和接收能力**，所以第三次握手才可以确认客户端的**接收能力**。不然容易出现丢包的现象



## CSS

## JS

#### 如何判断变量是否为数组？

```js
Array.isArray(arr);
arr instanceof Array;
Object.prototype.toString.call(arr) === '[object Array]';
```

#### 根据 0.1+0.2 ! == 0.3，讲讲 IEEE 754 ，如何让其相等？

原因: 

- **进制转换:** js数字计算时, 会转换为二进制. 最大存储 **53位** 有效数字, 大于会被截掉. 导致精度丢失
- **对阶运算:** 由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（`0舍1入`），尾数位移时可能会发生数丢失的情况，影响精度

如何让其相等, 

- 字符串相加

```js
// 字符串数字相加
var addStrings = function (num1, num2) {
  let i = num1.length - 1;
  let j = num2.length - 1;
  const res = [];
  let carry = 0;
  while (i >= 0 || j >= 0) {
    const n1 = i >= 0 ? Number(num1[i]) : 0;
    const n2 = j >= 0 ? Number(num2[j]) : 0;
    const sum = n1 + n2 + carry;
    res.unshift(sum % 10);
    carry = Math.floor(sum / 10);
    i--;
    j--;
  }
  if (carry) {
    res.unshift(carry);
  }
  return res.join("");
};

function isEqual(a, b, sum) {
  const [intStr1, deciStr1] = a.toString().split(".");
  const [intStr2, deciStr2] = b.toString().split(".");
  const inteSum = addStrings(intStr1, intStr2); // 获取整数相加部分
  const deciSum = addStrings(deciStr1, deciStr2); // 获取小数相加部分
  return inteSum + "." + deciSum === String(sum);
}

console.log(isEqual(0.1, 0.2, 0.3)); // true
```

#### new 实现

 new 实现了哪些功能?

- 能访问构造函数的属性
- 把这个对象的构造原型(`__proto__`)指向函数的原型对象`prototype`，并绑定this
- 能访问函数原型中的属性.
- 如果构造函数带返回值. 返回类型如果是对象. 则返回这个对象. 否则还是实例对象. 

```js
function New(fn) [
  var obj = {}
  obj.__proto__ = fn.prototype;
  var res = fn.apply(obj, [...arguments.slice(1)])
  return typeof res === 'object' ? res : obj; 
]
```

Promise.all 的实现

```js
// Promise.all([A, B])
Promise.all = function(arr) {
    let result = []
    return new Promise((resolve, reject)=>{
        let remaining = arr.length
        function res(val, i) {
            try {
                if (val && (typeof val === 'function' || typeof val === 'object')) {
                    const {
                        then
                    } = val;
                    // 遗漏
                    if (typeof then === 'function') {
                        
                        then.call(
                            val,
                        	function(value) {
                                res(value, i)
                            },
                        	reject
                        );
                        return; 
                    }
                }
                result[i] = val;
                if (--remaining === 0) {
                    resolve(result)
                }
            } catch(error) {
                reject(error)
            }

        }
        for (let i = 0; i < arr.length; i++) {
            res(arr[i], i)
        }
    })
}
```

## [http](https://juejin.cn/post/6844904100035821575)

#### GET 和 POST 的区别。

- 从**缓存**的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。

- 从**编码**的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。

- 从**参数**的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。

- 从**幂等性**的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)

- 从 **TCP** 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)

#### 简要概括一下 HTTP 的特点？HTTP 有哪些缺点？

特点: 

1. **灵活可扩展**，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。
2. **无状态**。这里的状态是指**通信过程的上下文信息**，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。
3. **无连接**  无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间
4. **简单快速** 客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快

缺点: 

1. **无状态** 对于长链接的场景来说, 需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。
2. **明文传输** 协议里的报文 是文本形式 这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。`WIFI陷阱`就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息
3. **队头阻塞问题 ** 当开始长链接. 同一时刻只能处理一个请求. 请求时间过长的情况下. 其他请求只能处于阻塞状态

#### HTTP1.1 如何解决 HTTP 的队头阻塞问题？

- **并发连接**

  - 对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。

- **域名分片**

  - 一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。

    比如 content1.sanyuan.com 、content2.sanyuan.com。

    这样一个`sanyuan.com`域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。

## React

### 为什么要自定义事件机制？

- 抹平浏览器差异，实现更好的跨平台。
- 避免垃圾回收，React 引入事件池，在事件池中获取或释放事件对象，避免频繁地去创建和销毁。
- 方便事件统一管理和事务机制。

### Class component

#### 生命周期

<img src="https://images.yewq.top/uPic/image-20220214230110035.png" alt="image-20220214230110035" style="zoom:150%;" />

挂载阶段: constructor() -> getDerivedStateFromProps() 返回一个对象更新state, 是否更新state -> render() -> 更新Dom树 -> componentDidMount() 

更新阶段:  getDerivedStateFromProps() -> shouldComponentUpdate() 是否更新这次. -> render() -> getSnapShotBeforeUpdate() 拿到更新前的Dom相关值 -> 更新Dom树 -> componentDidUpdate()

卸载阶段: componentWillUnmount()

### hook

#### 为什么不能在条件语句中写 hook

hook 在每次渲染时的查找是根据一个“全局”的下标对链表进行查找的，如果放在条件语句中使用，有一定几率会造成拿到的状态出现错乱.

#### HOC 和 hook 的区别

hook 复用**逻辑**. HOC复用**逻辑和视图**

#### useEffect 和 useLayoutEffect 区别

函数组件一次state更新的过程: 

1. 某state发生了变化
2. React内部更新state
3. 处理更新组件的Dom节点
4. Dom更新渲染
5. Dom更新后 (Layout阶段后)

`useEffect` 在第 4 步之后执行，且是异步的，保证了不会阻塞浏览器进程。 `useLayoutEffect` 在第 3 步至第 4 步之间执行，且是同步代码，所以会阻塞后面代码的执行

#### useEffect 依赖为空数组与 componentDidMount 区别

在 `render` 执行之后，`componentDidMount` 会执行，如果在这个生命周期中再一次 `setState` ，会导致再次 `render` ，返回了新的值，浏览器只会渲染第二次 `render` 返回的值，这样可以避免闪屏。

但是 `useEffect` 是在真实的 DOM 渲染之后才会去执行，这会造成两次 `render` ，有可能会闪屏。(useEffect时commit完成后异步调用)

实际上 `useLayoutEffect` 会更接近 `componentDidMount` 的表现，它们都同步执行且会阻碍真实的 DOM 渲染的。 useLayoutEffect和componentDidMount调用时机一致，也是在layout阶段同步调用.

#### React.memo() 和 React.useMemo() 的区别

- memo是高阶组件. 浅比较props, 引用类型可以用第二个参数手动比价
- useMemo 返回一个缓存值. 只有依赖项发生变化才会重新执行.
- useCallback 根据依赖项缓存函数

  - 有很多时候，我们在 `useEffect` 中使用某个定义的外部函数，是要添加到 `deps` 数组中的，如果不用 `useCallback` 缓存，这个函数在每次重新渲染时都是一个完全新的函数，也就是引用地址发生了变化，这就会导致 `useEffect` 总会无意义的执行。


## Webpack

### webpack5 和 webpack4 的区别有哪些 ？





## 经历

### 虚拟DOM

- 虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI。
- 实现了对 DOM 的集中化操作，在数据改变时先对虚拟 DOM 进行修改，再反映到真实的 DOM 中，用最小的代价来更新 DOM，提高效率(提升效率要想想是跟哪个阶段比提升了效率，别只记住了这一条)。

> 缺点

- 首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。(首屏慢)
- 虚拟 DOM 需要在内存中的维护一份 DOM 的副本 (空间上)
- 

### react使用优势?

1. 虚拟Dom
2. 组件化 将页面拆分成若干个组件，并且react一个组件同时耦合了css，js ,image，这种模式整个垫付了过去的传统模式
3. JSX语法
4. 单向数据流

是个库. 项目使用需要引入react-router, 数据管理react-redux配合

### react 怎么diff?

react的diff 策略

- **同级diff, 忽略跨层级的移动操作**
- **不同类型的组件生成不同的树**
- **同层级子节点可以使用key作为区分**

其中Diff分为两类：

1. 当`newChild`类型为`object`、`number`、`string`，代表同级只有一个节点
2. 当`newChild`类型为`Array`，同级有多个节点

同级的节点的diff分为:
**单节点diff**: 
先看上次的更新child是否存在. 

	- 不存在 新建fiber节点
	- 存在看是否能够复用
		- 先看key是否相同
			- key不相同 将该fiber标记为删除, 后面可能还有兄弟fiber.
			- key相同 接下来看type是否相同
				- type相同则复用
				- type不相同 将该fiber及其兄弟fiber全部标记为删除


**多节点diff**: 
>虽然本次更新的JSX对象 newChildren为数组形式，但是和newChildren中每个组件进行比较的是current fiber，同级的Fiber节点是由sibling指针链接形成的单链表，即不支持双指针遍历。
>
>在日常开发中，相较于`新增`和`删除`，`更新`组件发生的频率更高。 所以`Diff`会优先判断当前节点是否属于`更新`。

Diff 分两轮遍历:

第一轮遍历:处理更新的节点
第二轮遍历: 处理剩下的不属于更新的节点

第一轮遍历:

1. `let newidx = 0`, 遍历`newChildren`; 将`newChildren[i]`与`oldFilber`进行比较. 如果可以复用, 继续遍历
2. `newidx++`; 继续将`newChildren[i]` 与 `oldFilber.sibling` 进行比较 . 如果可以复用, 继续遍历
3. 如果不可以复用, 分两种:
   1. `key `不同 **直接第一轮遍历结束**
   2. `key `相同` type`不同.  将oldFilber标记删除, 继续遍历
4. 如果` newChildren` 遍历完 ( `newIdx === newChildren.length - 1 `) 或者` oldFiber `遍历完 `oldFiber === bull `, 跳出遍历，**第一轮遍历结束。**

第一轮遍历的结果会有几种情况:

1. `newChildren` 与 `oldFiber` 都遍历完了 --- 说明这次只是更新节点,` Diff` 结束
2. `newChilderen`遍历完了, `oldFilber`没有遍历完 --- 说明这次删除节点, 只需将剩下`oldFilber`标记` deletion`
3. `newChilderen`没有遍历完, `oldFilber`遍历完了 --- 说明这次新增节点, 只需将剩下` newChilderen` 遍历生成`filber` 标记为新增
4. `newChilderen`和 `oldFilber`都没有遍历完, --- 说明这次更新中改变了位置

第二轮遍历: 

>  没遍历完的节点

由于有节点改变了位置，所以不能再用位置索引`i`对比前后的节点，那么如何才能将同一个节点在两次更新中对应上呢？

我们需要使用`key`。

为了快速的找到`key`对应的`oldFiber`，我们将所有还未处理的`oldFiber`存入以`key`为key，`oldFiber`为value的`Map`中。

```javascript
const existingChildren = mapRemainingChildren(returnFiber, oldFiber);
```

接下来遍历剩余的`newChildren`，通过`newChildren[i].key`就能在`existingChildren`中找到`key`相同的`oldFiber`。

- 找到相同key	
  - type是否相同 可复用 
    - 可复用 existingChildren.delete(newFiber.key)
  - 不可复用 新建fiber
- 没找到新建fiber

剩余existingChildren如果还有 遍历筛入deletions

改变了位置的情况

### react性能优化? 项目上的性能优化?

React(代码层面): 

- 组件: React.useMemo; PureComponent, shouldComponentUpdate
- 函数: useCallback. useMemo;
- 避免内联函数.
- React.lazy与 React.Suspense
- 减少渲染(重排和重绘)
- 防抖和节流（resize，scroll，input）。

构建上的性能优化: 

- **CDN加速**: **output.publicPath** 静态资源配置cdn
- **压缩css** plugin: `optimize-css-assets-webpack-plugin` `cssnano`
- **压缩html**: `HtmlWebpackPlugin.minify ` 
- **tree shaking 清除无用的css, js**: 
  - css: glob-all@3.2.1 `purify-css@1.2.5` `purifycss-webpack@0.7.0` 
  - js: `optimization.usedExports`: true 且只有mode: 'production'才生效. 消除副作用: package.json中的 sideEffects: ['*.less', '*.css', '@babel/polyfill'] // 免除消除
- **代码分割 optimization.splitChunks **: 分离公共文件. 
- **开启 gzip 压缩** webpack 中使用 `compression-webpack-plugin` ，node 作为服务器也要开启，使用 `compression`。

其它：

- 使用 http2。因为解析速度快，头部压缩，多路复用，服务器推送静态资源。
- 使用服务端渲染。
- 图片压缩。
- 使用 http 缓存，比如服务端的响应中添加 `Cache-Control / Expires` 。

### react组件间通信

**参考答案：**

以下6种方法是react组件间通信的方式：

- 父组件向子组件通讯: 父组件可以向子组件通过传 props 的方式，向子组件进行通讯
- 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中
- 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信息进行通信
- 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再适合不过
- 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入event模块进行通信
- 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维护一个全局状态中心Store,并根据不同的事件产生新的状态

### webpack 压缩js的插件?

多线程压缩js:  webpack-parallel-uglify-plugin, 

- `uglifyjs-webpack-plugin`：不支持 ES6 压缩 (Webpack4 以前)
- `terser-webpack-plugin`: 支持压缩 ES6 (Webpack4)

### hook与class组件的区别?

- hook写法更简洁. 比class更` 声明式`

- hook使得函数组件更容易复用. 比class更` 函数式`

- 复杂组件中 class起初简单. 后面逐渐被状态逻辑和副作用充斥. 每个生命周期包含不相关的逻辑. 难以拆分. 而hook,可以将组件相互关联的部分拆分成更小的函数, 例如请求数据, 设置订阅等. 而非按生命周期来划分.

- hook可以使你在无需改变组件结构的情况下复用状态逻辑. Class组件复用状态逻辑需要使用高级组件嵌套,或者provider. render props

  

### 使用typescript的好处?

- 增加了代码的可读性和可维护性
  - 类型系统实际上是最好的文档
  - 可以在编译阶段就发现大部分错误
  - 增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等
- 静态类型检查



### redux使用流程?

![img](https://images.yewq.top/2547292-cae4b69ca467d0f3.png)

首先由view dispatch拦截action，然后执行对应reducer并更新到store中，最终views会根据store数据的改变执行界面的刷新渲染操作。

![img](https://images.yewq.top/164edab5e41258c1~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

• **单一数据源** 

• **State是只读的**

• **应用状态的改变通过纯函数来完成** 

**redux异步处理 redux-thunk**



### 浅拷贝的方法, 且解构符与浅拷贝的区别?

解构赋值是浅拷贝一层, 属性如果是对象, 是对象引用

```js
// 对象
var obj1 = {a: 1, b: 2}
// Object.assign
 var obj2 = Object.assign({}, obj1)
// 解构赋值

// 数组
// slice()
var arr = arr.slice()
var arr = [].concat(arr)
// 遍历
// 展开符

```



### react中setState与Vue的赋值区别?

两者对数据的处理不一样

- vue    是数据的劫持和通知订阅的方式，所以可以立即响应数据的变化。 值的改变却是同步的, dom的更新是异步的
- react数据更新setState是异步的

### 小程序经验过期 分包处理

### v-if v-show 是否会导致重排重绘?

（1）两者都会导致页面的重绘和重排，但v-show只是改变dom的css，而v-if控制的是添加和删除dom，所以v-if在重绘重排前还进行了添加或删除dom元素的操作。
（2）需要多次切换某个元素的显示或隐藏时使用v-show
（3）某个元素在渲染后就一直存在或隐藏时使用v-if
（4）opacity也可以隐藏元素，但它本身的作用并非用来隐藏元素而是设置元素的透明度，并且opacity为0时，该dom同样占用着空间。

### hash 和 history的使用场景?

**Hash:**

原理:

- 早期的前端路由的实现就是基于`location.hash`来实现的，`location.hash`的值就是URL中#后面的内容 其实现原理就是监听#后面的内容来发起Ajax请求来进行局部更新，而不需要刷新整个页面。

- 使用`hashchange`事件来监听 URL 的变化，以下这几种情况改变 URL 都会触发 hashchange 事件：浏览器前进后退改变 URL、a标签改变 URL、window.location改变URL。

优点: 

- hash值的改变，都会在浏览器的访问历史中增加一个记录，所以可以通过浏览器的回退、前进按钮控制hash的切换 会覆盖锚点定位元素的功能

**History模式**

- history 提供了 pushState 和 replaceState 两个方法来记录路由状态，这两个方法改变 URL 不会引起页面刷新

- history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过pushState/replaceState或a标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState/replaceState的调用和a标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。

- pushState(state, title, url) 和 replaceState(state, title, url)都可以接受三个相同的参数。



两种不同使用场景

- 从上文可见，hash模式下url会带有#，当你希望url更优雅时，可以使用history模式。
- 当使用history模式时，需要注意在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。
- **当需要兼容低版本的浏览器时，建议使用hash模式。**
- **当需要添加任意类型数据到记录时，可以使用history模式。**



### SEO meta的知识复习

```html
<meta name='description' content={`${description}`} />
<meta name='keywords' content={`${keywords}`} />
```



### [前端安全漏洞](https://www.cnblogs.com/zs-note/p/11122483.html)

XSS攻击: 一种`代码注入攻击`，通过恶意注入脚本在浏览器运行，然后盗取用户信息

CSRF攻击: `跨站请求伪造攻击`，**主要就是利用用户的登录状态发起跨站请求*



### [浏览器渲染过程](https://347830076.github.io/myBlog/javascript/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E6%B5%81%E7%A8%8B.html#%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B)

解析HTML->构建DOM -> 构建CSSOM -> 构建**渲染**树-> 布局(回流->重绘)-> 绘制。

![img](https://images.yewq.top/browerFlow.png)



### [浏览器是单线程吗](https://imweb.io/topic/58e3bfa845e5c13468f567d5)

浏览器内核是多线程

- GUI 渲染线程
- JavaScript引擎线程
- 定时触发器线程
- 事件触发线程
- 异步http请求线程



### [虚拟列表 滚动位置的实现](https://juejin.cn/post/6844904183582162957#heading-15)

![未命名作品 2.jpg](https://images.yewq.top/7eec1a54f9f94e3f8f50c306c0263572~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

滚动条配置: 

10万条; 滚动条比例过小. 给定最小高度.  按照比例来赋值

- 视口能渲染几个列表元素？
  - 需要我们给每一个列表元素设置一个高度。通过累加高度计算找到第一个加完它的高度后总高度超出视口高度的列表元素。
- 怎么知道该渲染哪几个元素？
  - 累加的元素高度 > 总偏移量 的时候返回元素序号
  -  视角的第一个元素的偏移量 = 总偏移量 - 累加元素的高度和 + 视角的第一元素的高度
- 列表元素咋渲染成我想要的？
  - 渲染列表视角的第一个元素 translateY

性能优化: 

- 事件节流
- 列表缓存(eg: 上下多渲染10条) 滚动量小的时候不用重新渲染列表

### 跨域名通信的方法

同源页面之间通信

- broadcast channel
- service worker
- LocalStorage
- indexedDB
- shared worker

非同源页面通信

- iframe
- postMessage

### 设计模式

### 闭包的好处, 优点

- 闭包就是能够读取其他函数内部变量的函数
- 由于在javascript中，只有函数内部的子函数才能读取局部变量，所以说，**闭包可以简单理解成“定义在一个函数内部的函数**。
- `在本质上，闭包是将函数内部和函数外部连接起来的桥梁`。

最大用处有两个, `一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在f1调用后被自动清除`。

好处: 

1. 希望一个变量长期保存内存中；

2. 避免全局变量污染；

3. 私有成员的存在。

缺点：

1. 常驻内存，增加内存使用量；

2. 使用不当造成内存泄漏。

### 回流布局(重排)

**Layout(回流)**:根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）

**css3硬件加速（GPU加速）** 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

### request 缓存

[SWR](https://zhuanlan.zhihu.com/p/158161974)

### Fiber

`React`内部实现的一套状态更新机制。支持任务不同`优先级`，可中断与恢复，并且恢复后可以复用之前的`中间状态`。

其中每个任务更新单元为`React Element`对应的`Fiber节点`。

1. 为什么需要fiber 
   - 对于⼤型项⽬，组件树会很⼤，这个时候递归遍历的 成本就会很⾼，会造成主线程被持续占⽤，结果就是 主线程上的布局、动画等周期性任务就⽆法⽴即得到 处理，造成视觉上的卡顿，影响⽤户体验。
2. 任务分解的意义 
   - 解决上⾯的问题
3. 增量渲染（把渲染任务拆分成块，匀到多帧） 
4. 更新时能够暂停，终⽌，复⽤渲染任务
5. 给不同类型的更新赋予优先级 
6. 并发⽅⾯新的基础能⼒ 
7. 更流畅

fiber是指组件上将要完成或者已经完成的任务，每个组 件可以⼀个或者多个。

- 第一阶段: 找出更新列表, 可中断.
- 第二阶段: 提交到Dom, 状态不可中断, requestIdleCallback()

React Fiber 是对核心算法的一次重新实现 Fiber reconciler 从 v16.x 开始底层使用 Fiber reconciler 替换 stack reconciler. 已知： stack reconciler 处理大状态时由于计算和组件树遍历的消耗容易出现渲染线程挂起，进而页面掉帧。（根本原因是渲染/更新过程一旦开始无法中断，持续占用主线程，主线程忙于执行 JS）

求： 建立一种能解决主线程占用问题，且具有长远意义的机制 解： 把渲染/更新过程拆分为小块任务，通过合理的调度机制来控制时间（更细粒度、更强的控制力）

子问题： 1.拆什么？什么不能拆？ 把渲染/更新过程分为 2 个阶段（diff + patch）： diff ~~render/reconciliation (对比 prevInstance 和 nextInstance 的状态，找出差异及其对应的 DOM change。) patch~~ commit (把本次更新中的所有 DOM change 应用到 DOM 树，是一连串的 DOM 操作。) render/reconciliation 阶段的工作（diff）可以拆分，commit 阶段的工作（patch）不可拆分.

2.怎么拆？ Fiber 的拆分单位是 fiber（fiber tree 上的一个节点），实际上就是按虚拟 DOM 节点拆，因为 fiber tree 是根据 vDOM tree 构造出来的，树结构一模一样，只是节点携带的信息有差异。

3.如何调度任务？ 分 2 部分： ￼ 工作循环 ￼ 优先级机制 工作循环是基本的任务调度机制，工作循环中每次处理一个任务（工作单元），处理完毕有一次喘息的机会，此时通过 shouldYield 函数（idleDeadline.timeRemaining()）判读时间是否用完，用完则把时间还给主线程等待下次 requestIdleCallback 的唤起，否则继续执行任务。 优先级机制用来处理突发事件与优化次序。 有如下策略： ￼ 到 commit 阶段了，提高优先级 ￼ 高优任务做一半出错了，给降一下优先级 ￼ 抽空关注一下低优任务，别给饿死了 ￼ 如果对应 DOM 节点此刻不可见，给降到最低优先级 是工作循环的辅助机制。

4.如何中断/断点恢复？ 中断：检查当前正在处理的工作单元，保存当前成果（firstEffect, lastEffect），修改 tag 标记一下，迅速收尾并再开一个 requestIdleCallback，下次有机会再做 断点恢复：下次再处理到该工作单元时，看 tag 是被打断的任务，接着做未完成的部分或者重做 自然中断（时间耗尽），或优先级中断（高优任务中断），原理相同。

5.如何收集任务结果？ 每个节点更新结束时向上归并 effect list 来收集任务结果，reconciliation 结束后，根节点的 effect list 里记录了包括 DOM change 在内的所有 side effect。

requestIdleCallback 让开发者在主事件循环中执行后台或低优先级的任务,不会对动画和用户交互等关键事件产生影响。

fiber 架构：

- 循环条件：利用 requestIdeCallback 空闲时间递减.
- 遍历过程：利用链表，找孩子找兄弟找父亲

### webpack兼容性处理

Css: 

配置postcss-loader , 并且在package.json中browserslist配置要兼容的浏览器版本

```js
/*
    postcss-loader：css兼容性处理：postcss --> 需要安装：postcss-loader postcss-preset-env
    postcss需要通过package.json中browserslist里面的配置加载指定的css兼容性样式
    在package.json中定义browserslist：
    "browserslist": {
      // 开发环境 --> 设置node环境变量：process.env.NODE_ENV = development
      "development": [ // 只需要可以运行即可
        "last 1 chrome version",
        "last 1 firefox version",
        "last 1 safari version"
      ],
      // 生产环境。默认是生产环境
      "production": [ // 需要满足绝大多数浏览器的兼容
        ">0.2%",
        "not dead",
        "not op_mini all"
      ]
    },
  */
  {
    loader: 'postcss-loader',
    options: {	
      ident: 'postcss', // 基本写法
      plugins: () => [
        // postcss的插件
        require('postcss-preset-env')(),
      ],
    },
  },
```



Js: 

babel-loader 

```js

/*
        js兼容性处理：需要下载 babel-loader @babel/core @babel/core: babel功能函数
          1. 基本js兼容性处理 --> @babel/preset-env
            问题：只能转换基本语法，如promise高级语法不能转换
          2. 全部js兼容性处理 --> @babel/polyfill
            问题：只要解决部分兼容性问题，但是将所有兼容性代码全部引入，体积太大了
          3. 需要做兼容性处理的就做：按需加载  --> core-js
      */
      {
        // 第三种方式：按需加载
        test: /\.js$/,
        exclude: /node_modules/,
        loader: 'babel-loader',
        options: {
          // 预设：指示babel做怎样的兼容性处理
          presets: [
            '@babel/preset-env', // 基本预设
            {
              useBuiltIns: 'usage', //按需加载
              corejs: { version: 3 }, // 指定core-js版本
              targets: { // 指定兼容到什么版本的浏览器
                chrome: '60',
                firefox: '50',
                ie: '9',
                safari: '10',
                edge: '17'
              },
            },
          ],
        },
      },
```



### Node 常用模块

### 项目难点

1. 项目中抽屉点击任何地方收回
2. [虚拟列表](#虚拟列表 滚动位置的实现)
3. 物理机升级node版本,启动报错. 本地和线上不一致. 从而推动项目docker部署, 从而保证本地和线上环境一致

### 数组扁平化

```js
function flat(arr) {
    var res = [];
    arr.forEach((item, i) => {
      if (Array.isArray(item)) {
        res = res.concat(flat(item));
      } else {
        res.push(item);
      }
    });
    return res;
  }
```

### 浏览器缓存

