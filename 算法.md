

##  知识点 

复杂度数组链表集合hash表栈队列 树图排序冒泡快速排序原地快排序.⼆分搜索

### 复杂度 

O的概念，来描述算法的复杂度，简⽽⾔之，就是算法执⾏所需要的执⾏次数，和数据量的关系( 时间复 杂度)， 占⽤额外空间和数据量的关系(空间复杂度) 

O(1) : 常数复杂度 (和数据量⽆关)

O(log n) :对数复杂度 (每次⼆分) 

O(n) : 线性时间复杂度 （数组遍历⼀次）

O(n*log n) : 线性对数 （遍历+⼆分） 

O(n^2) : 平⽅ 两层遍历 

O(n^3) : ⽴⽅ 

O(2^n) : 指数 O(n!) : 阶乘

![image-20220121151906239](https://images.yewq.top/image-20220121151906239.png)

### 稳定性 

数组中[ {name:'xx', age:12}, {name:'kaikeba', age:12}] 如果按照age排序，排序后，xx和kaikeba的相 对位置不变，我们成为稳定的算法，否则不稳定

### 排序

搜索和排序，是计算机的⼏个基本问题

排序算法是《数据结构与算法》中最基本的算法之一。

排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：

![img](https://images.yewq.top/sort.png)

点击以下图片查看大图：

[![img](https://images.yewq.top/0B319B38-B70E-4118-B897-74EFA7E368F9.png)](https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png)

**关于时间复杂度**

平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。

线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；

O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序

线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。

关于稳定性

稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。

不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。

名词解释：

- n：数据规模
- k："桶"的个数
- In-place：占用常数内存，不占用额外内存
- Out-place：占用额外内存
- 稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同

#### 冒泡

最经典和简单粗暴的排序算法，简⽽⾔之，就是挨个对⽐，如果⽐右边的数字⼤，就交换位置 遍历⼀ 次，最⼤的在最右边，重复步骤，完成排序

![img](https://images.yewq.top/bubbleSort.gif)

```js

var bubbleSort = function (arr) {
  var bool = true;
  while(bool) {
    bool = false
    for (let i = 0; i < arr.length; i++) {
      if(arr[i] > arr[i+1]) {
        [arr[i], arr[i+1]] = [arr[i+1], arr[i]];
        bool = true
      }      
    }
  }
  return arr
}

// 反向遍历 由于最右侧的值已经有序，不再比较，每次都减少遍历次数
var bubbleSort2 = function (arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    for (let j = 0; j < i; j++) {
      if(arr[j] > arr[j+1]) {
        [arr[j], arr[j+1]] = [arr[j+1], arr[j]]
      }
    }
  }
  return arr
}
```

问题：冒泡复杂度和稳定性如何 ?

n^2 空间 1 稳定

#### 插⼊

插⼊排序逻辑和冒泡类似，只不过没采⽤挨个交换的逻辑，⽽是在⼀个已经排好序的数组⾥，插⼊⼀个 元素，让它依然是有序的

通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

![img](https://images.yewq.top/insertionSort.gif)



![img](https://images.yewq.top/1024555-20161126000335346-416319390.png)

```js
function insertionSort(arr) {
  var len = arr.length;
  for (var i = 1; i < len; i++) { //外循环从1开始，默认arr[0]是有序段
    for (let j = i; j > 0; j--) {
      if(arr[j] < arr[j-1]) {
        [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]];
      } else {
        break;
      }
    }
  }
  return arr;
}
```

n^2 空间 1 稳定

#### 快速排序

使⽤了⼆分的思想。可以算最重要的排序算法了 ⼤概就是找⼀个标志位，先遍历⼀次，所有个头⽐他矮的，都站左边，⽐他个头⾼的，都站右边，遍历 ⼀次，就把数组分成两部分，然后两遍的数组，递归执⾏相同的逻辑

便于理解, 额外占⽤空间.

```js
function quickSort(arr) {
  if (arr.length <= 1) {
    return arr; //递归出⼝
  }
  var left = [],
    right = [],
    current = arr.splice(0, 1); //注意splice后，数组⻓度少了⼀个
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] < current) {
      left.push(arr[i]); //放在左边
    } else {
      right.push(arr[i]); //放在右边
    }
  }
  return quickSort(left).concat(current, quickSort(right)); //递归
}
```



```js
// 原地版
function quickSort1(arr, low = 0, high = arr.length - 1) {
  if (low >= high) return;
  let left = low;
  let right = high;
  let temp = arr[left];
  while (left < right) {
    if (left < right && temp <= arr[right]) {
      right--;
    }
    arr[left] = arr[right];
    if (left < right && temp >= arr[left]) {
      left++;
    }
    arr[right] = arr[left];
  }
  arr[left] = temp;
  quickSort1(arr, low, left - 1);
  quickSort1(arr, left + 1, high);
  return arr;
}
console.log(quickSort1([11, 4, 3, 6, 1, 9, 7, 2, 0]));
```

#### 归并

归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。

作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：

- 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；
- 自下而上的迭代；

 **算法步骤**: 

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；
4. 重复步骤 3 直到某一指针达到序列尾；
5. 将另一序列剩下的所有元素直接复制到合并序列尾。

图解来源: https://www.cnblogs.com/chengxiao

![img](https://images.yewq.top/1557906108-5066-20161218163120151-452283750.png)

```js
// 分解
function mergeSort(arr) {
    if(arr.length < 2) {
      return arr;
  	}
    let middle = Math.floor(arr.length / 2);
    let left = arr.slice(0, middle);
    let right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}
// 治
function merge(left, right) {
  let result = []
  while(left.length && right.length) {
    if(left[0] < right[0]) {
      result.push(left.shift());
    } else {
      result.push(right.shift());
    }
  }
  while(left.length) result.push(left.shift());
  while(right.length) result.push(right.shift());
  return result;
}
```

